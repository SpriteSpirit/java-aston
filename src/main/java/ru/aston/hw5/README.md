# Паттерны проектирования: Стратегия, Цепочка обязанностей, Билдер, Прокси, Декоратор, Адаптер

Этот документ содержит описание шести паттернов проектирования: Стратегия, Цепочка обязанностей,
Билдер, Прокси, Декоратор и Адаптер. Для каждого паттерна представлено лаконичное объяснение
назначения, структуры, сценариев использования, примеров реализации на Java и ключевых нюансов.
Документация предназначена для разработчиков, желающих изучить или применить эти паттерны в своих
проектах.

---

## 1. Стратегия (Strategy)

### Назначение

Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.
Позволяет выбирать алгоритм во время выполнения программы.

### Структура

- **Интерфейс Strategy**: Определяет метод для выполнения алгоритма.
- **Конкретные стратегии**: Реализуют интерфейс, предоставляя конкретные алгоритмы.
- **Контекст**: Содержит ссылку на стратегию и использует её для выполнения задачи.

### Сценарии использования

- Выбор алгоритма сортировки (например, пузырьковая, быстрая).
- Обработка сообщений разными способами (email, SMS, push).
- Построение маршрутов (автомобильный, пешеходный).

### Пример

```java
interface SortStrategy {

    void sort(int[] array);
}

class BubbleSort implements SortStrategy {

    public void sort(int[] array) {
        System.out.println("Пузырьковая сортировка");
    }
}

class Sorter {

    private SortStrategy strategy;

    public void setStrategy(SortStrategy strategy) {
        this.strategy = strategy;
    }

    public void sortArray(int[] array) {
        strategy.sort(array);
    }
}
```

### Нюансы

- **Преимущества**: Гибкость, изоляция алгоритмов, тестируемость.
- **Недостатки**: Увеличение числа классов.
- **Когда избегать**: Если алгоритмы редко меняются или их мало.

---

## 2. Цепочка обязанностей (Chain of Responsibility)

### Назначение

Передаёт запрос по цепочке обработчиков, где каждый решает, обработать запрос или передать дальше.

### Структура

- **Абстрактный обработчик**: Определяет интерфейс обработки и ссылку на следующий обработчик.
- **Конкретные обработчики**: Реализуют логику обработки.
- **Клиент**: Инициирует запрос.

### Сценарии использования

- Обработка запросов на одобрение (например, расходов).
- Логирование событий разными уровнями.
- Фильтрация HTTP-запросов в веб-приложениях.

### Пример

```java
abstract class Approver {

    protected Approver next;

    public void setNext(Approver next) {
        this.next = next;
    }

    public abstract void approveRequest(int amount);
}

class Manager extends Approver {

    public void approveRequest(int amount) {
        if (amount <= 1000) {
            System.out.println("Менеджер одобрил: " + amount);
        } else if (next != null) {
            next.approveRequest(amount);
        }
    }
}
```

### Нюансы

- **Преимущества**: Гибкость, упрощение добавления обработчиков.
- **Недостатки**: Возможность необработки запроса, снижение производительности при длинной цепочке.
- **Когда избегать**: Если запрос всегда обрабатывается одним объектом.

---

## 3. Билдер (Builder)

### Назначение

Пошагово конструирует сложные объекты, разделяя процесс создания от их представления.

### Структура

- **Builder**: Интерфейс или класс с методами настройки параметров.
- **Конкретный Builder**: Реализует процесс создания.
- **Продукт**: Конечный объект.
- **Директор** (опционально): Управляет сборкой.

### Сценарии использования

- Создание объектов с множеством параметров (например, заказы, конфигурации).
- Построение сложных структур данных (например, HTML-документы).

### Пример

```java
class Car {

    private final String engine;
    private final String color;

    public Car(String engine, String color) {
        this.engine = engine;
        this.color = color;
    }

    public String toString() {
        return "Car [engine=" + engine + ", color=" + color + "]";
    }
}

class CarBuilder {

    private String engine, color;

    public CarBuilder setEngine(String engine) {
        this.engine = engine;
        return this;
    }

    public CarBuilder setColor(String color) {
        this.color = color;
        return this;
    }

    public Car build() {
        return new Car(engine, color);
    }
}
```

### Нюансы

- **Преимущества**: Читаемость, поддержка иммутабельности.
- **Недостатки**: Дополнительный класс Builder.
- **Когда избегать**: Для простых объектов с малым числом параметров.

---

## 4. Прокси (Proxy)

### Назначение

Предоставляет суррогат для объекта, контролируя доступ к нему (например, для ленивой инициализации
или логирования).

### Структура

- **Интерфейс**: Определяет методы для прокси и реального объекта.
- **Реальный объект**: Выполняет основную работу.
- **Прокси**: Контролирует доступ.

### Сценарии использования

- Ленивая загрузка данных (например, изображений).
- Контроль доступа (например, проверка прав).
- Кэширование результатов.

### Пример

```java
interface Image {

    void display();
}

class RealImage implements Image {

    private final String filename;

    public RealImage(String filename) {
        this.filename = filename;
        System.out.println("Загрузка: " + filename);
    }

    public void display() {
        System.out.println("Отображение: " + filename);
    }
}

class ProxyImage implements Image {

    private RealImage realImage;
    private final String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}
```

### Нюансы

- **Преимущества**: Оптимизация ресурсов, контроль доступа.
- **Недостатки**: Дополнительный слой абстракции.
- **Когда избегать**: Если нет необходимости в контроле или оптимизации.

---

## 5. Декоратор (Decorator)

### Назначение

Динамически добавляет обязанности объекту без изменения его кода.

### Структура

- **Компонент**: Интерфейс для объектов.
- **Конкретный компонент**: Базовый объект.
- **Декоратор**: Реализует интерфейс и содержит ссылку на компонент.
- **Конкретные декораторы**: Добавляют функциональность.

### Сценарии использования

- Расширение функциональности (например, добавление скидок к заказу).
- Модификация данных (например, форматирование текста).

### Пример

```java
interface Beverage {

    String getDescription();

    double cost();
}

class Espresso implements Beverage {

    public String getDescription() {
        return "Эспрессо";
    }

    public double cost() {
        return 1.99;
    }
}

abstract class BeverageDecorator implements Beverage {

    protected Beverage beverage;

    public BeverageDecorator(Beverage beverage) {
        this.beverage = beverage;
    }
}

class Milk extends BeverageDecorator {

    public Milk(Beverage beverage) {
        super(beverage);
    }

    public String getDescription() {
        return beverage.getDescription() + ", Молоко";
    }

    public double cost() {
        return beverage.cost() + 0.5;
    }
}
```

### Нюансы

- **Преимущества**: Гибкость, прозрачность для клиента.
- **Недостатки**: Множество мелких классов.
- **Когда избегать**: Если функциональность можно реализовать наследованием.

---

## 6. Адаптер (Adapter)

### Назначение

Позволяет объектам с несовместимыми интерфейсами работать вместе, преобразуя один интерфейс в
другой.

### Структура

- **Целевой интерфейс**: Ожидаемый клиентом интерфейс.
- **Адаптируемый класс**: Класс с несовместимым интерфейсом.
- **Адаптер**: Реализует целевой интерфейс, вызывая методы адаптируемого класса.

### Сценарии использования

- Интеграция старого кода с новым API.
- Поддержка разных форматов данных (например, JSON, XML).

### Пример

```java
interface NewMediaPlayer {

    void play(String audioType, String fileName);
}

class OldMediaPlayer {

    public void playMp3(String fileName) {
        System.out.println("Воспроизведение MP3: " + fileName);
    }
}

class MediaAdapter implements NewMediaPlayer {

    private final OldMediaPlayer oldPlayer = new OldMediaPlayer();

    public void play(String audioType, String fileName) {
        if (audioType.equalsIgnoreCase("mp3")) {
            oldPlayer.playMp3(fileName);
        } else {
            System.out.println("Формат не поддерживается");
        }
    }
}
```

### Нюансы

- **Преимущества**: Совместимость без изменения исходного кода.
- **Недостатки**: Ограниченность функциональности адаптируемого класса.
- **Когда избегать**: Если интерфейсы можно унифицировать напрямую.

---

## Рекомендации по применению

- **Анализ задачи**: Определите, решает ли паттерн конкретную проблему (например, гибкость, контроль
  доступа).
- **Простота**: Избегайте избыточного усложнения для простых задач.
- **Тестирование**: Проверяйте реализацию паттернов в различных сценариях.
- **Документация**: Описывайте выбор паттерна для поддержки кода.

Эти паттерны проектирования являются фундаментальными инструментами для создания гибких,
поддерживаемых и масштабируемых приложений на Java.
