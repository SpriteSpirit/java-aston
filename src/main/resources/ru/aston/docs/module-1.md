# Основы Java: Модуль 1

## Языки программирования

Языки программирования классифицируются по различным признакам:

- **Уровень абстракции**: Низкоуровневые (C, Assembly) и высокоуровневые (Java, Python).
- **Парадигма**: Процедурные (C), объектно-ориентированные (Java, C++), функциональные (Haskell),
  скриптовые (JavaScript, Python).
- **Назначение**: Общего назначения (Java, Python), специализированные (SQL для баз данных, R для
  статистики).
- **Типизация**: Статическая (Java, C++) и динамическая (Python, JavaScript).
- **Способ выполнения**: Компилируемые (Java, C++) и интерпретируемые (Python, PHP).

## JVM, JRE, JDK

- **JVM (Java Virtual Machine)**: Виртуальная машина, исполняющая байт-код Java. Обеспечивает
  платформонезависимость.
- **JRE (Java Runtime Environment)**: Среда выполнения, включающая JVM и стандартные библиотеки для
  запуска Java-программ.
- **JDK (Java Development Kit)**: Набор инструментов для разработки, включающий JRE, компилятор (
  javac), утилиты (javadoc, jar).

## Области памяти в Java

- **Heap**: Хранит объекты и массивы. Управляется сборщиком мусора.
- **Stack**: Хранит локальные переменные и стек вызовов методов для каждого потока.
- **Metaspace**: Хранит метаданные классов (заменил PermGen в Java 8+).
- **Non-Heap (Code Cache)**: Хранит скомпилированный JIT-код.
- **String Pool**: Часть Heap, хранит уникальные строки-литералы.

## Class Loaders

**Class Loaders** загружают классы в JVM во время выполнения.

- **Виды**:
    - **Bootstrap Class Loader**: Загружает стандартные библиотеки Java (rt.jar).
    - **Extension Class Loader**: Загружает расширения из папки `jre/lib/ext`.
    - **Application Class Loader**: Загружает классы из пути приложения (classpath).
- **Назначение**: Динамическая загрузка классов, обеспечение модульности и безопасности (изоляция
  классов).

## Объект класса Class

Объект класса `Class` представляет метаданные о классе в JVM (имя, методы, поля). Получается через:

- `Class.forName("ClassName")`
- `ClassName.class`
- `object.getClass()`
  Используется для рефлексии (динамического анализа и вызова методов/полей).

## Классы и объекты

- **Класс**: Шаблон, описывающий структуру и поведение объектов (поля, методы).
- **Объект**: Экземпляр класса, созданный через `new`.
  Пример:

```java
class Car {
    String model;
    void drive() { /* логика */ }
}
Car car = new Car(); // объект
```

## Структура класса

Класс содержит:

- Поля (переменные).
- Конструкторы.
- Методы.
- Статические/нестатические блоки инициализации.
- Внутренние/вложенные классы.
  Пример:

```java
class Example {
    int field; // поле
    Example() { /* конструктор */ }
    void method() { /* метод */ }
}
```

## Поля

Поля — переменные, хранящие состояние объекта или класса.

- **Экземплярные**: Принадлежат объекту (`int x`).
- **Статические**: Принадлежат классу (`static int count`).

## Конструкторы

Конструкторы инициализируют объект при создании.

- **Ключевое слово `super`**: Вызывает конструктор родительского класса.
- **Ключевое слово `this`**: Ссылается на текущий объект или вызывает другой конструктор того же
  класса.
  Пример:

```java
class Car {
    String model;
    Car(String model) {
        this.model = model; // this для поля
    }
}
class SportsCar extends Car {
    SportsCar(String model) {
        super(model); // вызов родительского конструктора
    }
}
```

## Методы

Методы определяют поведение объекта.

- **Сигнатура метода**: Имя, параметры, возвращаемый тип (например, `int add(int a, int b)`).
- **Перегрузка методов**: Методы с одинаковым именем, но разными параметрами.
  Пример:

```java
class Calculator {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; } // перегрузка
}
```

## Статические и нестатические блоки инициализации

- **Статический блок**: Выполняется один раз при загрузке класса.
- **Нестатический блок**: Выполняется при создании каждого объекта.
  Пример:

```java
class Example {
    static { System.out.println("Статический блок"); }
    { System.out.println("Нестатический блок"); }
}
```

## Модификаторы

### static, final, abstract

- **static**: Принадлежит классу, а не объекту (например, `static int count`).
- **final**: Нельзя изменить (переменная), переопределить (метод) или наследовать (класс).
- **abstract**: Указывает, что класс/метод не реализован; требует наследования для реализации.

### private, protected, public, package-private

- **private**: Доступ только внутри класса.
- **protected**: Доступ в классе, подклассах и пакете.
- **public**: Доступ отовсюду.
- **package-private** (без модификатора): Доступ внутри пакета.

## Варианты установки значений свойств объектов

- **Поля**:
    - Плюсы: Простота, прямой доступ.
    - Минусы: Нарушение инкапсуляции, нет валидации.
- **Конструкторы**:
    - Плюсы: Инициализация при создании, валидация.
    - Минусы: Нельзя изменить после создания.
- **Сеттеры**:
    - Плюсы: Гибкость, валидация, инкапсуляция.
    - Минусы: Дополнительный код, возможна некорректная установка.

Пример:

```java
class Person {
    private String name; // поле
    Person(String name) { this.name = name; } // конструктор
    void setName(String name) { this.name = name; } // сеттер
}
```

## Абстрактные классы и интерфейсы

- **Абстрактный класс**: Содержит абстрактные методы (без реализации) и/или реализованные методы.
  Нельзя создать объект.
- **Интерфейс**: Содержит только абстрактные методы (до Java 8) или методы с реализацией (`default`,
  `static` в Java 8+).
- **Отличия**:
    - Абстрактный класс может содержать состояние (поля), интерфейс — нет (до Java 8).
    - Класс наследует один абстрактный класс (`extends`), но реализует несколько интерфейсов (
      `implements`).
- **Где использовать**:
    - Абстрактный класс: Когда нужна общая реализация и состояние (например, базовый класс
      `Vehicle`).
    - Интерфейс: Для контракта без состояния (например, `Comparable`).

## Изменяемые и неизменяемые объекты

- **Изменяемые**: Объекты, чьи поля можно изменить после создания (например, `ArrayList`).
- **Неизменяемые**: Объекты, чьи поля неизменны после создания.
    - Примеры: `String`, `Integer`, `LocalDate`.
    - Как сделать класс неизменяемым:
        - Поля `final` и `private`.
        - Отсутствие сеттеров.
        - Конструктор для инициализации.
        - Глубокое копирование изменяемых полей.
        - Методы возвращают новые объекты вместо изменения текущего.
    - Пример:
      ```java
      final class Immutable {
          private final int value;
          Immutable(int value) { this.value = value; }
          int getValue() { return value; }
      }
      ```

## Inner и Nested классы

- **Inner (внутренний)**: Класс внутри другого класса, имеет доступ к полям внешнего объекта.
- **Nested (вложенный)**: Static класс внутри другого, не требует экземпляра внешнего класса.
  Пример:

```java
class Outer {
    class Inner { /* доступ к Outer.this */ }
    static class Nested { /* независим */ }
}
```

## Локальные и анонимные классы

- **Локальный**: Класс, определенный внутри метода. Доступен только в этом методе.
- **Анонимный**: Класс без имени, создается для одноразового использования (обычно для реализации
  интерфейса).
  Пример:

```java
interface Action { void perform(); }
Action action = new Action() { // анонимный класс
    public void perform() { System.out.println("Action"); }
};
```

## Класс Object

Базовый класс для всех объектов в Java. Все классы неявно наследуют `Object`.

## Методы класса Object

- `toString()`: Возвращает строковое представление объекта.
- `equals(Object)`: Сравнивает объекты на равенство.
- `hashCode()`: Возвращает хэш-код объекта.
- `getClass()`: Возвращает объект `Class`.
- `clone()`: Создает копию объекта.
- `finalize()`: Вызывается перед сборкой мусора (устарел).
- `wait()`, `notify()`, `notifyAll()`: Для синхронизации потоков.

## Контракт equals-hashCode

- Если `equals()` возвращает `true` для двух объектов, их `hashCode()` должен быть одинаковым.
- Если `hashCode()` различается, `equals()` должен возвращать `false`.
  Пример:

```java
class Person {
    private String name;
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;
        Person person = (Person) o;
        return name.equals(person.name);
    }
    @Override
    public int hashCode() { return name.hashCode(); }
}
```

## Метод clone

Создает копию объекта. Требует реализации интерфейса `Cloneable` и переопределения `clone()`.
Пример:

```java
class MyClass implements Cloneable {
    int value;
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

## Принципы ООП

- **Инкапсуляция**: Сокрытие данных через `private` поля и публичные методы.
- **Наследование**: Передача свойств и методов от родительского класса к дочернему.
- **Полиморфизм**: Выполнение разных действий в зависимости от типа объекта (через переопределение
  или интерфейсы).
- **Абстракция**: Сокрытие деталей реализации, предоставление только интерфейса.

## Наследование и ассоциация

- **Наследование** (`extends`):
    - Определение: Дочерний класс наследует свойства и методы родительского.
    - Плюсы: Повторное использование кода, иерархия.
    - Минусы: Жесткая связь, усложняет изменения.
- **Ассоциация** (включает композицию и агрегацию):
    - Определение: Связь между объектами через поля или параметры.
    - Плюсы: Гибкость, слабая связь.
    - Минусы: Больше кода для управления связями.
      Пример:

```java
class Engine {}
class Car extends Engine {} // наследование
class Car { Engine engine; } // ассоциация (композиция)
```

## Переопределение методов

Переопределение (`@Override`) позволяет дочернему классу изменить реализацию метода родителя.
Пример:

```java
class Animal {
    void sound() { System.out.println("Sound"); }
}
class Dog extends Animal {
    @Override
    void sound() { System.out.println("Bark"); }
}
```

## Статическое и динамическое связывание

- **Статическое**: Выбор метода на этапе компиляции (для `static`, `final`, `private` методов).
- **Динамическое**: Выбор метода на этапе выполнения (для переопределенных методов).
  Пример:

```java
Animal dog = new Dog();
dog.sound(); // динамическое связывание, вызовет Dog.sound()
```

## Оболочки примитивных типов

- **Оболочки**: `Integer`, `Double`, `Boolean` и др. для примитивов (`int`, `double`, `boolean`).
- **API**: Методы, такие как `Integer.parseInt(String)`, `Double.valueOf(double)`.
- **Особенности сравнения**:
    - Для значений в диапазоне [-128, 127] оболочки кэшируются, `==` работает.
    - Вне диапазона или для других типов используйте `equals()`.
      Пример:

```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b); // true (кэширование)
Integer c = 200;
Integer d = 200;
System.out.println(c == d); // false (новые объекты)
```

## String

`String` — неизменяемый класс для работы со строками.

- **String Pool**: Хранит уникальные строки-литералы в Heap для экономии памяти.
- **Создание**:
    - `String s = "hello";` // строка в пуле
    - `String s = new String("hello");` // новый объект
- **API**:
    - `length()`: Длина строки.
    - `substring(int, int)`: Извлечение подстроки.
    - `equals(String)`: Сравнение строк.
    - `split(String)`: Разделение строки.
    - `toUpperCase()`, `toLowerCase()`: Изменение регистра.

## StringBuilder, StringBuffer

- **StringBuilder**: Неизменяемый, небезопасный для потоков, быстрый. Используется для построения
  строк.
- **StringBuffer**: Неизменяемый, потокобезопасный, медленнее. Используется в многопоточных
  приложениях.
  Пример:

```java
StringBuilder sb = new StringBuilder();
sb.append("Hello").append("World");
String result = sb.toString(); // "HelloWorld"
```
