# Работа с Java Stream API

## Введение

Java Stream API, введённый в Java 8, предоставляет мощный и выразительный способ обработки коллекций
данных (например, списков, массивов) в функциональном стиле. Потоки позволяют выполнять операции над
данными, такие как фильтрация, преобразование, сортировка и агрегация, в декларативной манере. Этот
документ объясняет основы Stream API, ключевые методы, примеры использования и типичные ошибки на
основе анализа кода из проекта `ru.aston.hw2.task2`.

## Что такое Stream?

`Stream` — это последовательность элементов, поддерживающая последовательные и параллельные
операции. Потоки не хранят данные, а обрабатывают их "на лету". Основные характеристики:

- **Ленивые вычисления**: Операции выполняются только при вызове терминальной операции.
- **Однократное использование**: Поток можно пройти только один раз.
- **Функциональный подход**: Операции не изменяют исходные данные (не мутируют коллекции).

## Основные методы Stream API

### 1. Создание потока

Потоки можно создать из коллекций, массивов или других источников:

- `List<T>.stream()`: Создаёт последовательный поток.
- `List<T>.parallelStream()`: Создаёт параллельный поток для многопоточной обработки.
- `Stream.of(T... values)`: Создаёт поток из набора элементов.
- `Arrays.stream(array)`: Создаёт поток из массива.

**Пример**:

```java
List<String> list = List.of("a", "b", "c");
Stream<String> stream = list.stream();
Stream<String> parallelStream = list.parallelStream();
Stream<Integer> numbers = Stream.of(1, 2, 3);
```

### 2. Промежуточные операции

Промежуточные операции преобразуют поток и возвращают новый поток. Они **ленивые** (не выполняются,
пока не вызвана терминальная операция).

- **`filter(Predicate<T>)`**: Оставляет элементы, удовлетворяющие условию.
  ```java
  list.stream()
      .filter(s -> s.length() > 1) // Оставляет строки длиной > 1
      .forEach(System.out::println);
  ```

- **`map(Function<T, R>)`**: Преобразует каждый элемент в новый.
  ```java
  list.stream()
      .map(String::toUpperCase) // Преобразует строки в верхний регистр
      .forEach(System.out::println);
  ```

- **`flatMap(Function<T, Stream<R>>)`**: Преобразует каждый элемент в поток и объединяет их в один.
  ```java
  List<List<Integer>> lists = List.of(List.of(1, 2), List.of(3, 4));
  lists.stream()
       .flatMap(List::stream) // Объединяет списки в один поток: [1, 2, 3, 4]
       .forEach(System.out::println);
  ```

- **`sorted(Comparator<T>)`**: Сортирует элементы.
  ```java
  list.stream()
      .sorted() // Сортировка по естественному порядку
      .forEach(System.out::println);
  ```

- **`distinct()`**: Удаляет дубликаты (требует корректных `equals` и `hashCode`).
  ```java
  list.stream()
      .distinct() // Удаляет одинаковые элементы
      .forEach(System.out::println);
  ```

- **`limit(long maxSize)`**: Ограничивает количество элементов.
  ```java
  list.stream()
      .limit(2) // Берёт первые 2 элемента
      .forEach(System.out::println);
  ```

- **`peek(Consumer<T>)`**: Выполняет действие для каждого элемента (обычно для отладки). **Осторожно
  **: избегайте побочных эффектов.
  ```java
  list.stream()
      .peek(System.out::println) // Выводит элементы для отладки
      .filter(s -> s.length() > 1)
      .forEach(System.out::println);
  ```

### 3. Терминальные операции

Терминальные операции завершают поток и возвращают результат (или ничего). После вызова терминальной
операции поток закрывается.

- **`forEach(Consumer<T>)`**: Выполняет действие для каждого элемента.
  ```java
  list.stream().forEach(System.out::println);
  ```

- **`collect(Collector)`**: Собирает элементы в коллекцию или строку.
  ```java
  String result = list.stream().collect(Collectors.joining(", "));
  // Результат: "a, b, c"
  ```

- **`findFirst()`**: Возвращает первый элемент потока (или `Optional.empty()`).
  ```java
  Optional<String> first = list.stream().findFirst();
  first.ifPresent(System.out::println);
  ```

- **`count()`**: Подсчитывает количество элементов.
  ```java
  long count = list.stream().filter(s -> s.length() > 1).count();
  ```

- **`anyMatch(Predicate<T>)`, `allMatch(Predicate<T>)`, `noneMatch(Predicate<T>)`**: Проверяют
  элементы по условию.
  ```java
  boolean hasLong = list.stream().anyMatch(s -> s.length() > 1);
  ```

### 4. Пример использования

Рассмотрим пример из проекта `ru.aston.hw2.task2`. Код обрабатывает список студентов и их книг,
находя год публикации первой книги, опубликованной после 2000 года, с минимальным количеством
страниц:

```Java
students.stream()
.

flatMap(student ->student.

getBooks().

stream())
    .

getBooks()
.

stream()) // Получаем все книги
    .

sorted(Comparator.comparingInt(Book::getPages)) // Сортировка по страницам
    .

distinct() // Удаляем дубликаты
.

filter(book ->book .
.

getPublishedYear() >2000) // Книги после 2000 года
    .

limit(3) // Первые 3 книги
.

map(Book::getPublishedYear) // Извлекаем годы
.

findFirst() // Берём первый год
.

ifPresentOrElse(
    year ->logger.

info("Год выпуска найденной книги: "+year),
        ()->logger.

info("Книга не найдена."));
```

**Результат**: Выводится год 2015, так как книга "Python for Beginners" (250 страниц, 2015) — первая
после сортировки по страницам среди книг, опубликованных после 2000 года.

## Лучшие практики

1. **Избегайте побочных эффектов**: Не используйте `peek` или `forEach` для изменения внешнего
   состояния. Стримы должны быть функциональными.
2. **Переопределяйте `toString`**: Всегда переопределяйте `toString` в пользовательских классах для
   читаемого вывода.
3. **Используйте `distinct` с осторожностью**: Убедитесь, что `equals` и `hashCode` реализованы
   корректно.
4. **Тестируйте потоки**: Используйте небольшие тестовые данные для проверки логики потока перед
   масштабированием.

## Заключение

Java Stream API — мощный инструмент для обработки данных, но требует понимания ленивых вычислений,
корректного использования методов и избегания побочных эффектов. Этот README охватывает основы
стримов, типичные ошибки (на примере `peek` и `toString`) и лучшие практики. Используйте этот
документ как руководство для написания чистого и эффективного кода с использованием Stream API.